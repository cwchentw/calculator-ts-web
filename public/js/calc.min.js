(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["calc"] = factory();
	else
		root["calc"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Type;
(function (Type) {
    Type[Type["EOF"] = 0] = "EOF";
    Type[Type["Integer"] = 1] = "Integer";
    Type[Type["Float"] = 2] = "Float";
    Type[Type["TNaN"] = 3] = "TNaN";
    Type[Type["TInfinity"] = 4] = "TInfinity";
    Type[Type["Add"] = 5] = "Add";
    Type[Type["Sub"] = 6] = "Sub";
    Type[Type["Mul"] = 7] = "Mul";
    Type[Type["Div"] = 8] = "Div";
    Type[Type["Mod"] = 9] = "Mod";
    Type[Type["Pow"] = 10] = "Pow";
    Type[Type["LeftParen"] = 11] = "LeftParen";
    Type[Type["RightParen"] = 12] = "RightParen";
})(Type = exports.Type || (exports.Type = {}));
var Token = (function () {
    function Token(t, s) {
        var _this = this;
        this.token = function () {
            return _this.t;
        };
        this.value = function () {
            return _this.str;
        };
        this.t = t;
        this.str = s;
    }
    return Token;
}());
exports.Token = Token;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AST = (function () {
    function AST() {
        var _this = this;
        this.token = function () {
            return _this.t;
        };
        this.toString = function () {
            var output = "";
            if (_this.t === null) {
                return output;
            }
            if (_this.children.length === 0) {
                return _this.t.value();
            }
            output += "(";
            output += _this.t.value();
            for (var i = 0; i < _this.children.length; i++) {
                if (_this.children[i] != null) {
                    output += " ";
                    output += _this.children[i].toString();
                }
            }
            output += ")";
            return output;
        };
    }
    return AST;
}());
exports.AST = AST;
var FactorAST = (function (_super) {
    __extends(FactorAST, _super);
    function FactorAST(t) {
        var _this = _super.call(this) || this;
        _this.t = t;
        _this.children = [];
        return _this;
    }
    return FactorAST;
}(AST));
exports.FactorAST = FactorAST;
var UniOpAST = (function (_super) {
    __extends(UniOpAST, _super);
    function UniOpAST(t, child) {
        var _this = _super.call(this) || this;
        _this.getChild = function () {
            return _this.children[0];
        };
        _this.t = t;
        _this.children = [];
        _this.children.push(child);
        return _this;
    }
    return UniOpAST;
}(AST));
exports.UniOpAST = UniOpAST;
var BiOpAST = (function (_super) {
    __extends(BiOpAST, _super);
    function BiOpAST(t, leftChild, rightChild) {
        var _this = _super.call(this) || this;
        _this.getLeftChild = function () {
            return _this.children[0];
        };
        _this.getRightChild = function () {
            return _this.children[1];
        };
        _this.t = t;
        _this.children = [];
        _this.children.push(leftChild);
        _this.children.push(rightChild);
        return _this;
    }
    return BiOpAST;
}(AST));
exports.BiOpAST = BiOpAST;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ast = __webpack_require__(1);
var lexer = __webpack_require__(3);
var parser = __webpack_require__(4);
var token = __webpack_require__(0);
var Evaluator = (function () {
    function Evaluator(s) {
        var _this = this;
        this.run = function () {
            return _this.interpreter.run();
        };
        this.interpreter =
            new Interpreter(new parser.Parser(new lexer.Lexer(s)));
    }
    return Evaluator;
}());
exports.Evaluator = Evaluator;
var Interpreter = (function () {
    function Interpreter(p) {
        var _this = this;
        this.run = function () {
            var ast = _this.parser.next();
            if (ast === null) {
                return null;
            }
            return _this.eval(ast);
        };
        this.eval = function (a) {
            if (a instanceof ast.BiOpAST) {
                var t = a.token();
                var left = _this.eval(a.getLeftChild());
                var right = _this.eval(a.getRightChild());
                if (t.token() === token.Type.Add) {
                    return left + right;
                }
                else if (t.token() === token.Type.Sub) {
                    return left - right;
                }
                else if (t.token() === token.Type.Mul) {
                    return left * right;
                }
                else if (t.token() === token.Type.Div) {
                    return left / right;
                }
                else if (t.token() === token.Type.Mod) {
                    return left % right;
                }
                else if (t.token() === token.Type.Pow) {
                    return Math.pow(left, right);
                }
                else {
                    throw new Error("Unable to eval unknown bi-op AST");
                }
            }
            else if (a instanceof ast.UniOpAST) {
                var t = a.token();
                var factor = _this.eval(a.getChild());
                if (t.token() === token.Type.Add) {
                    return factor;
                }
                else if (t.token() === token.Type.Sub) {
                    return -factor;
                }
                else {
                    throw new Error("Unable to eval unknown uni-op AST");
                }
            }
            else if (a instanceof ast.FactorAST) {
                var t = a.token();
                if (t.token() === token.Type.Integer) {
                    return parseInt(t.value(), 10);
                }
                else if (t.token() === token.Type.Float) {
                    return parseFloat(t.value());
                }
                else if (t.token() === token.Type.TNaN) {
                    return NaN;
                }
                else if (t.token() === token.Type.TInfinity) {
                    return Infinity;
                }
                else {
                    throw new Error("Unable to eval unknown factor");
                }
            }
            else {
                throw new Error("Unable to eval unknown AST");
            }
        };
        this.parser = p;
    }
    return Interpreter;
}());
exports.Interpreter = Interpreter;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var token = __webpack_require__(0);
var Lexer = (function () {
    function Lexer(input) {
        var _this = this;
        // Get next token.
        this.next = function () {
            _this.index += 1;
            if (_this.index >= _this.tokens.length) {
                return null;
            }
            return _this.tokens[_this.index];
        };
        // Peek next token without advancing steps.
        this.peek = function () {
            if (_this.index + 1 >= _this.tokens.length) {
                return null;
            }
            return _this.tokens[_this.index + 1];
        };
        // Run a finite automata.
        this.run = function () {
            var state = _this.updateState;
            while (state != null) {
                // Change state.
                state = state();
            }
        };
        this.updateState = function () {
            if (_this.current >= _this.strArray.length) {
                _this.tokens.push(new token.Token(token.Type.EOF, "EOF"));
                // Change state to over.
                return null;
            }
            var s = _this.peekString();
            if (s === "(") {
                return _this.lexKeyword(1, token.Type.LeftParen);
            }
            else if (s === ")") {
                return _this.lexKeyword(1, token.Type.RightParen);
            }
            else if (s === "+") {
                return _this.lexKeyword(1, token.Type.Add);
            }
            else if (s === "-") {
                return _this.lexKeyword(1, token.Type.Sub);
            }
            else if (s === "*") {
                return _this.lexTimes();
            }
            else if (s === "/") {
                return _this.lexKeyword(1, token.Type.Div);
            }
            else if (s === "%") {
                return _this.lexKeyword(1, token.Type.Mod);
            }
            else if (_this.isUpper(s)) {
                return _this.lexWord();
            }
            else if (_this.isDigit(s) || _this.isDot(s)) {
                return _this.lexNumber();
            }
            else if (_this.isSpace(s)) {
                _this.offset += 1;
                _this.current += 1;
                _this.update();
                return _this.updateState;
            }
            else {
                throw new Error("Unknown string: " + s);
            }
        };
        this.lexWord = function () {
            var w = _this.strArray.slice(_this.pos);
            if (w.length >= 8) {
                if (w.slice(0, 8).join("") === "Infinity") {
                    _this.offset += 8;
                    _this.current += 8;
                    _this.appendToken(token.Type.TInfinity);
                    _this.update();
                    return _this.updateState;
                }
            }
            if (w.length >= 3) {
                if (w.slice(0, 3).join("") === "NaN") {
                    _this.offset += 3;
                    _this.current += 3;
                    _this.appendToken(token.Type.TNaN);
                    _this.update();
                    return _this.updateState;
                }
            }
            var s = _this.peekString();
            throw new Error("Unknow string: " + s);
        };
        this.lexNumber = function () {
            var s = _this.peekString();
            if (s === ".") {
                throw new Error("Number with leading dot.");
            }
            while (true) {
                if (_this.isDigit(s)) {
                    _this.offset += 1;
                    _this.current += 1;
                }
                else if (_this.isDot(s)) {
                    _this.offset += 1;
                    _this.current += 1;
                    return _this.lexFloat();
                }
                else {
                    break;
                }
                if (_this.isOutOfBound()) {
                    break;
                }
                s = _this.peekString();
            }
            _this.appendToken(token.Type.Integer);
            _this.update();
            return _this.updateState;
        };
        this.lexFloat = function () {
            var s = ".";
            var isDupDot = false;
            while (true) {
                if (_this.isDigit(s)) {
                    _this.offset += 1;
                    _this.current += 1;
                }
                else if (_this.isDot(s)) {
                    if (!isDupDot) {
                        _this.offset += 1;
                        _this.current += 1;
                        isDupDot = true;
                    }
                    else {
                        throw new Error("Duplicated dot in number");
                    }
                }
                else {
                    break;
                }
                if (_this.isOutOfBound()) {
                    break;
                }
                s = _this.peekString();
            }
            _this.appendToken(token.Type.Float);
            _this.update();
            return _this.updateState;
        };
        this.lexTimes = function () {
            if (_this.pos + 2 <= _this.strArray.length) {
                _this.current += 1;
                if (_this.peekString() === "*") {
                    return _this.lexKeyword(2, token.Type.Pow);
                }
            }
            return _this.lexKeyword(1, token.Type.Mul);
        };
        this.lexKeyword = function (offset, t) {
            _this.offset += offset;
            _this.current += offset;
            _this.appendToken(t);
            _this.update();
            return _this.updateState;
        };
        this.appendToken = function (t) {
            var s = _this.strArray.slice(_this.pos, _this.pos + _this.offset).join("");
            _this.tokens.push(new token.Token(t, s));
        };
        this.peekString = function () {
            return _this.strArray[_this.current];
        };
        this.isUpper = function (s) {
            return (s === "A" || s === "B" || s === "C" || s === "D" || s === "E" ||
                s === "F" || s === "G" || s === "H" || s === "I" || s === "J" ||
                s === "K" || s === "L" || s === "M" || s === "N" || s === "O" ||
                s === "P" || s === "Q" || s === "R" || s === "S" || s === "T" ||
                s === "U" || s === "V" || s === "W" || s === "X" || s === "Y" ||
                s === "Z");
        };
        this.isDigit = function (s) {
            return (s === "0" || s === "1" || s === "2" || s === "3" || s === "4" ||
                s === "5" || s === "6" || s === "7" || s === "8" || s === "9");
        };
        this.isDot = function (s) {
            return s === ".";
        };
        this.isSpace = function (s) {
            return (s === " " || s === "\t");
        };
        this.isOutOfBound = function () {
            return _this.current > _this.strArray.length;
        };
        this.update = function () {
            _this.pos += _this.offset;
            _this.offset = 0;
            _this.current = _this.pos;
        };
        // Initialize some values.
        this.pos = 0;
        this.current = 0;
        this.offset = 0;
        this.index = -1;
        this.strArray = input.split("");
        this.tokens = [];
        // Run a finite automata.
        this.run();
    }
    return Lexer;
}());
exports.Lexer = Lexer;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ast = __webpack_require__(1);
var token = __webpack_require__(0);
var Parser = (function () {
    function Parser(lexer) {
        var _this = this;
        this.next = function () {
            _this.index += 1;
            if (_this.index > _this.stmt.length - 1) {
                return null;
            }
            return _this.stmt[_this.index];
        };
        this.run = function () {
            _this.currentToken = _this.lexer.next();
            while (_this.currentToken !== null) {
                var expr = _this.parseExpr();
                if (expr === null) {
                    break;
                }
                _this.stmt.push(expr);
                if (_this.currentToken.token() === token.Type.EOF) {
                    _this.eat(token.Type.EOF);
                }
            }
        };
        // expr: TERM ((Add|Sub) TERM)
        this.parseExpr = function () {
            var expr = _this.parseTerm();
            if (expr === null) {
                return null;
            }
            while (_this.currentToken.token() === token.Type.Add ||
                _this.currentToken.token() === token.Type.Sub) {
                var t = _this.currentToken;
                if (t.token() === token.Type.Add) {
                    _this.eat(token.Type.Add);
                }
                if (t.token() === token.Type.Sub) {
                    _this.eat(token.Type.Sub);
                }
                var other = _this.parseTerm();
                if (other === null) {
                    throw new Error("Uneven " + t.value() + " expression");
                }
                expr = new ast.BiOpAST(t, expr, other);
            }
            return expr;
        };
        // term: VALUE ((Mul|Div|Mod) VALUE)
        this.parseTerm = function () {
            var term = _this.parseValue();
            if (term === null) {
                return null;
            }
            while (_this.currentToken.token() === token.Type.Mul ||
                _this.currentToken.token() === token.Type.Div ||
                _this.currentToken.token() === token.Type.Mod) {
                var t = _this.currentToken;
                if (t.token() === token.Type.Mul) {
                    _this.eat(token.Type.Mul);
                }
                if (t.token() === token.Type.Div) {
                    _this.eat(token.Type.Div);
                }
                if (t.token() === token.Type.Mod) {
                    _this.eat(token.Type.Mod);
                }
                var other = _this.parseValue();
                if (other === null) {
                    throw new Error("Uneven " + t.value() + " term");
                }
                term = new ast.BiOpAST(t, term, other);
            }
            return term;
        };
        // value: FACTOR ((Pow) FACTOR)
        this.parseValue = function () {
            var value = _this.parseFactor();
            if (value === null) {
                return null;
            }
            while (_this.currentToken.token() === token.Type.Pow) {
                var t = _this.currentToken;
                if (t.token() === token.Type.Pow) {
                    _this.eat(token.Type.Pow);
                }
                var other = _this.parseFactor();
                if (other === null) {
                    throw new Error("Uneven " + t.value() + " value");
                }
                value = new ast.BiOpAST(t, value, other);
            }
            return value;
        };
        // factor: (Add/Sub) Integer|Float|NaN|Infinity
        this.parseFactor = function () {
            var t = _this.currentToken;
            if (t.token() === token.Type.Integer) {
                _this.eat(token.Type.Integer);
                return new ast.FactorAST(t);
            }
            else if (t.token() === token.Type.Float) {
                _this.eat(token.Type.Float);
                return new ast.FactorAST(t);
            }
            else if (t.token() === token.Type.TNaN) {
                _this.eat(token.Type.TNaN);
                return new ast.FactorAST(t);
            }
            else if (t.token() === token.Type.TInfinity) {
                _this.eat(token.Type.TInfinity);
                return new ast.FactorAST(t);
            }
            else if (t.token() === token.Type.Add) {
                _this.eat(token.Type.Add);
                return new ast.UniOpAST(t, _this.parseFactor());
            }
            else if (t.token() === token.Type.Sub) {
                _this.eat(token.Type.Sub);
                return new ast.UniOpAST(t, _this.parseFactor());
            }
            else if (t.token() === token.Type.LeftParen) {
                _this.eat(token.Type.LeftParen);
                var expr = _this.parseExpr();
                _this.eat(token.Type.RightParen);
                return expr;
            }
            else if (t.token() === token.Type.EOF) {
                _this.eat(token.Type.EOF);
                return null;
            }
            else if (t === null) {
                return null;
            }
            else {
                throw new Error("Unknown token: " + t.value());
            }
        };
        this.eat = function (t) {
            if (t !== _this.currentToken.token()) {
                throw new Error("Wrong token: -->" + _this.currentToken.value() + "<--");
            }
            _this.currentToken = _this.lexer.next();
        };
        this.lexer = lexer;
        this.stmt = [];
        this.index = -1;
        this.run();
    }
    return Parser;
}());
exports.Parser = Parser;


/***/ })
/******/ ]);
});